filter {

# Privafy filter version 1.0.0
# Based on (User Doc) https://docs.progress.com/es-ES/bundle/loadmaster-technical-note-common-event-format-cef-logs-ga/page/Common-Event-Format-CEF-Logs.html (December, 2023)
# and (User Doc) https://help.deepsecurity.trendmicro.com/20_0/on-premise/event-syslog-message-formats.html (December, 2023)
# and example logs provided by user during POC
# Note: This is a filter developed to integrate with generic pipeline, so, needs entrypoint, if not set goes to generic

    split {
      field => "message"
      terminator => "<utm-log-separator>"
    }

    #Looking for datasource generated by an agent and parse original message
    if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
      grok {
       match => {
          "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
        }
      }
    }
    if [original_log_message] {
      mutate {
        update => { "message" => "%{[original_log_message]}" }
      }
    }

    if ![dataType] {
#......................................................................#
# Privafy Entry point
     if [message] and ("CEF:" in [message] and [message] =~/\|(\w+)?(\s)?Privafy(\s)?(\w+)?\|/ ) {
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if exists, if not evaluate to the host variable
           if (![dataSource]){
              mutate {
               add_field => { "dataSource" => "%{host}" }
              }
           }
#......................................................................#
#Generating dataType field required by CurrelationRulesEngine
              mutate {
               add_field => { "dataType" => "privafy" }
              }
#......................................................................#
#If CEF formatted log do the parsing of the message
        if ("CEF:" in [message] ) {
#......................................................................#
#Using grok to parse header of the message
            grok {
              match => {
                "message" => [
                   "(%{INT:not_defined})?(\s)?(<%{NUMBER:priority}>)?(%{INT:syslog_version})?((\s)%{GREEDYDATA:syslog_date_host}(\s))?CEF:(\s)?%{INT:cef_version}%{GREEDYDATA:cef_msg_all}"
                ]
              }
            }
#......................................................................#
#Using grok to parse components of the cef_message_all
          if [cef_msg_all] {
            grok {
              match => {
                "cef_msg_all" => [
                   "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:embDeviceVersion}\|%{DATA:embEventClassID}\|%{DATA:embName}\|%{DATA:severity}\|%{GREEDYDATA:cef_msg}",
                   "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:embEventClassID}\|%{DATA:embName}\|%{DATA:severity}\|%{GREEDYDATA:cef_msg}",
                   "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{GREEDYDATA:cef_msg}"
                ]
              }
            }
          }
        }
#......................................................................# 
#First, replace whitespaces with default string after = to avoid kv issues, example:
#gattServices= manufacturerName=MFN, generates -> gattServices="manufacturerName=MFN"
#and should generate two fields: gattServices and manufacturerName
    if [cef_msg] {
      mutate {
        gsub => [
          "cef_msg", "(\w+)= ", "\1=X0X "
        ]
      }
#......................................................................#
#Using the kv filter with default config, usefull in key-value logs

      kv { 
        source => "cef_msg" 
        allow_duplicate_values => false
        target => "kv_field"
      }
    }
#......................................................................#
#Remove fields that have issues with kv filter (spaces or = in value)
   mutate {
      remove_field => ["[kv_field][command_line]","[kv_field][username]","[kv_field][activity]","[kv_field][description]"]
   }
#......................................................................#
#Using grok to parse kv issued fields
          grok {
            match => {
              "cef_msg" => [
                 "command_line=%{DATA:command_line} %{WORD}=(%{GREEDYDATA:irrelevant})?"
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "username=%{DATA:src_user} %{WORD}=(%{GREEDYDATA:irrelevant})?"
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "activity=%{DATA:activity} %{WORD}=(%{GREEDYDATA:irrelevant})?"
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "description=%{DATA:description} %{WORD}=(%{GREEDYDATA:irrelevant})?"
              ]
            }
          }
#......................................................................#
#Add fields to the tree structure
#......................................................................#
        mutate {
          #Rename the filds out of kv results
          rename => { "[embEventClassID]" => "[kv_field][embEventClassID]" }
          rename => { "[embDeviceVendor]" => "[kv_field][embDeviceVendor]" }
          rename => { "[embDeviceProduct]" => "[kv_field][embDeviceProduct]" }
          rename => { "[embName]" => "[kv_field][embName]" }
          rename => { "[cef_version]" => "[kv_field][cef_version]" }
          rename => { "[embDeviceVersion]" => "[kv_field][embDeviceVersion]" }
          rename => { "[priority]" => "[kv_field][priority]" }
          rename => { "[severity]" => "[kv_field][severity]" }
          rename => { "[end_msg]" => "[kv_field][end_msg]" }
          rename => { "[message]" => "[kv_field][message]" }

          #Generating other fields
          rename => { "[kv_field][srcIP]" => "[kv_field][src_ip]" }
          rename => { "[kv_field][destIP]" => "[kv_field][dest_ip]" }
          rename => { "[kv_field][srcPort]" => "[kv_field][src_port]" }
          rename => { "[kv_field][destPort]" => "[kv_field][dest_port]" }
          rename => { "[kv_field][protocol]" => "[kv_field][proto]" }
          
          #Rename fields with kv issues (individual groks)
          rename => { "[command_line]" => "[kv_field][command_line]" }
          rename => { "[src_user]" => "[kv_field][src_user]" }
          rename => { "[activity]" => "[kv_field][activity]" }
          rename => { "[description]" => "[kv_field][description]" }

        }
#......................................................................#
# Converting some fields to number
      mutate {
       convert => {
         "[kv_field][src_port]" => "integer"
         "[kv_field][dest_port]" => "integer"
       }
}
#......................................................................#	   
#Decoding severity
if [kv_field][severity]{
  if [kv_field][severity] == "9" or [kv_field][severity] == "10" {
   mutate {
     add_field => {
       "[logx][privafy][severityLabel]" => "Very-High"
     }
   }	
  } else if [kv_field][severity] == "7" or [kv_field][severity] == "8" {
   mutate {
     add_field => {
       "[logx][privafy][severityLabel]" => "High"
     }
   }	
  } else if [kv_field][severity] >= "4" and [kv_field][severity] <= "6" {
   mutate {
     add_field => {
       "[logx][privafy][severityLabel]" => "Medium"
     }
   }	
  } else {
   mutate {
     add_field => {
       "[logx][privafy][severityLabel]" => "Low"
     }
   }	
  }
}
#......................................................................#
#Set null the fields with de X0X value (default string for null), and replace simple and double quotation
#also generate logx tree structure dynamically
          if [kv_field] {  
            ruby {
                code => '
                    event.get("[kv_field]").each do |k, v|
                          if (v == "X0X") 
                            event.set("[logx][privafy][#{k}]",nil)
                          elsif !(v.kind_of?(Array))
                              new_v = v.to_s.gsub(/\"/, "")
                              new_v = new_v.gsub(/\'/, "")
                              event.set("[logx][privafy][#{k}]",new_v)
                          else
                              event.set("[logx][privafy][#{k}]",v)
                          end
                       end   
                    '
            }
          }
#......................................................................#
   #Finally, remove unnecessary fields
   mutate {
      remove_field => ["@version","path","tags","type","syslog_version","kv_field",
      "not_defined","cef_msg_all","cef_msg","syslog_date_host","irrelevant","init_msg"]
   }
  }
# End CEF entrypoint
 }

   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["@version","path","original_log_message","headers"]
   }
}
