filter {

# Privafy filter version 1.1.2
# Based on (User Doc) https://docs.progress.com/es-ES/bundle/loadmaster-technical-note-common-event-format-cef-logs-ga/page/Common-Event-Format-CEF-Logs.html (December, 2023)
# and (User Doc) https://help.deepsecurity.trendmicro.com/20_0/on-premise/event-syslog-message-formats.html (December, 2023)
# and example logs provided by user during POC
# LEEF:Version|Vendor|Product|Version|EventID|(DelimiterCharacter) disponible en 2.0|
# LEEF:1.0|Microsoft|MSExchange|4.0 SP1|15345|
# LEEF:2.0|Lancope|StealthWatch|1.0|41|x5E|
# Note: This is a filter developed to integrate with generic pipeline, so, needs entrypoint, if not set goes to generic

    split {
      field => "message"
      terminator => "<utm-log-separator>"
    }

    #Looking for datasource generated by an agent and parse original message
    if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
      grok {
       match => {
          "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
        }
      }
    }
    if [original_log_message] {
      mutate {
        update => { "message" => "%{[original_log_message]}" }
      }
    }

#......................................................................#
# Creating privafy message field from syslog message    
    if [logx][syslog][message] {
      mutate {
        add_field => { "prvf_message" => "%{[logx][syslog][message]}" }
      }
    } else {
      mutate {
        add_field => { "prvf_message" => "%{message}" }
      }
    }
#......................................................................#
# Privafy Entry point
     if [prvf_message] and (("CEF:" in [prvf_message] or "LEEF:" in [prvf_message]) and [prvf_message] =~/\|(\w+)?(\s)?Privafy(\s)?(\w+)?\|/ ) {
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if exists, if not evaluate to the host variable
           if (![dataSource]){
              mutate {
               add_field => { "dataSource" => "%{host}" }
              }
           }
#......................................................................#
#Generating dataType field required by CurrelationRulesEngine
            if (![dataType]){
              mutate {
               add_field => { "dataType" => "privafy" }
              }
            } else {
              mutate {
               update => { "dataType" => "privafy" }
              }
            }
#......................................................................#
#If CEF or LEEF formatted log do the parsing of the prvf_message mark as undefined syslog format
        if ("CEF:" in [prvf_message] or "LEEF:" in [prvf_message] ) {
#......................................................................#
#Using grok to parse header of the prvf_message
            grok {
              match => {
                "prvf_message" => [
                   "(%{INT:not_defined})?(\s)?(<%{NUMBER:priority}>)?(%{INT:syslog_version})?((\s)%{GREEDYDATA:syslog_date_host}(\s))?(?<format_type>(CEF|LEEF)):(\s)?(?<format_version>(%{INT}\.%{INT}|%{INT}))%{GREEDYDATA:cef_or_leef_msg_all}"
                ]
              }
            }
        }
        if ("CEF:" in [prvf_message] ) {
#......................................................................#
#Using grok to parse components of the cef_or_leef_msg_all
          if [cef_or_leef_msg_all] {
            grok {
              match => {
                "cef_or_leef_msg_all" => [
                   "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:embDeviceVersion}\|%{DATA:embEventClassID}\|%{DATA:embName}\|%{DATA:embSeverity}\|%{GREEDYDATA:cef_or_leef_msg}",
                   "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:embEventClassID}\|%{DATA:embName}\|%{DATA:embSeverity}\|%{GREEDYDATA:cef_or_leef_msg}",
                   "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{GREEDYDATA:cef_or_leef_msg}"
                ]
              }
            }
          }
        } else if ("LEEF:" in [prvf_message] ) {
#......................................................................#
#Using grok to parse components of the leef_message
          if [cef_or_leef_msg_all] {  
            grok {
              match => {
                "cef_or_leef_msg_all" => [
                   "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:embDeviceVersion}\|%{DATA:embEventClassID}\|%{DATA:DelimiterCharacter}\|%{GREEDYDATA:cef_or_leef_msg}",
                   "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:embEventClassID}\|%{DATA:DelimiterCharacter}\|%{GREEDYDATA:cef_or_leef_msg}",
                   "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{GREEDYDATA:cef_or_leef_msg}"
                ]
              }
            }
          }
        }
#......................................................................# 
#First, replace whitespaces with default string after = to avoid kv issues, example:
#gattServices= manufacturerName=MFN, generates -> gattServices="manufacturerName=MFN"
#and should generate two fields: gattServices and manufacturerName
    if [cef_or_leef_msg] {
      mutate {
        gsub => [
          "cef_or_leef_msg", "(\w+)= ", "\1=X0X "
        ]
      }
#......................................................................#
#Using the kv filter with default config, usefull in key-value logs

      kv { 
        source => "cef_or_leef_msg" 
        allow_duplicate_values => false
        target => "kv_field"
      }
    }
#......................................................................#
#Remove fields that have issues with kv filter (spaces or = in value)
   mutate {
      remove_field => ["[kv_field][command_line]","[kv_field][username]","[kv_field][activity]","[kv_field][description]",
      "[kv_field][parent_path]","[kv_field][path]"]
   }
#......................................................................#
#Using grok to parse kv issued fields
          grok {
            match => {
              "cef_or_leef_msg" => [
                 "command_line=%{DATA:command_line}\s(\b([a-zA-Z0-9_]+)\b)=(%{GREEDYDATA:irrelevant})?"
              ]
            }
          }

          grok {
            match => {
              "cef_or_leef_msg" => [
                 "username=%{DATA:src_user} %{WORD}=(%{GREEDYDATA:irrelevant})?"
              ]
            }
          }

          grok {
            match => {
              "cef_or_leef_msg" => [
                 "activity=%{DATA:activity} %{WORD}=(%{GREEDYDATA:irrelevant})?"
              ]
            }
          }

          grok {
            match => {
              "cef_or_leef_msg" => [
                 "description=%{DATA:description} %{WORD}=(%{GREEDYDATA:irrelevant})?"
              ]
            }
          }

          grok {
            match => {
              "cef_or_leef_msg" => [
                 "parent_path=%{DATA:parent_path} %{WORD}=(%{GREEDYDATA:irrelevant})?"
              ]
            }
          }

          grok {
            match => {
              "cef_or_leef_msg" => [
                 "path=%{DATA:path} %{WORD}=(%{GREEDYDATA:irrelevant})?"
              ]
            }
          }
#......................................................................#
#Add fields to the tree structure
#......................................................................#
        mutate {
          #Rename the filds out of kv results
          rename => { "[embEventClassID]" => "[kv_field][embEventClassID]" }
          rename => { "[embDeviceVendor]" => "[kv_field][embDeviceVendor]" }
          rename => { "[embDeviceProduct]" => "[kv_field][embDeviceProduct]" }
          rename => { "[embName]" => "[kv_field][embName]" }
          rename => { "[embDeviceVersion]" => "[kv_field][embDeviceVersion]" }
          rename => { "[priority]" => "[kv_field][priority]" }
          rename => { "[embSeverity]" => "[kv_field][embSeverity]" }
          rename => { "[format_version]" => "[kv_field][format_version]" }
          rename => { "[format_type]" => "[kv_field][format_type]" }
          rename => { "[end_msg]" => "[kv_field][end_msg]" }
          rename => { "[prvf_message]" => "[kv_field][message]" }

          #Generating other fields
          rename => { "[kv_field][srcIP]" => "[kv_field][src_ip]" }
          rename => { "[kv_field][destIP]" => "[kv_field][dest_ip]" }
          rename => { "[kv_field][srcPort]" => "[kv_field][src_port]" }
          rename => { "[kv_field][destPort]" => "[kv_field][dest_port]" }
          rename => { "[kv_field][protocol]" => "[kv_field][proto]" }
          
          #Rename fields with kv issues (individual groks)
          rename => { "[command_line]" => "[kv_field][command_line]" }
          rename => { "[src_user]" => "[kv_field][src_user]" }
          rename => { "[activity]" => "[kv_field][activity]" }
          rename => { "[description]" => "[kv_field][description]" }
          rename => { "[parent_path]" => "[kv_field][parent_path]" }
          rename => { "[path]" => "[kv_field][path]" }

        }
#......................................................................#
# Converting some fields to number
      mutate {
       convert => {
         "[kv_field][src_port]" => "integer"
         "[kv_field][dest_port]" => "integer"
       }
}
#......................................................................#	   
# Decoding severity
#......................................................................#
# First, we check if severity is present (Privafy alarms, has a severity field in extension fields)
# Otherwise we take the header severity field 
if ![kv_field][severity]{
  mutate {
    rename => { "[kv_field][embSeverity]" => "[kv_field][severity]" }
  }
}  else {
  mutate {
      remove_field => ["[kv_field][embSeverity]"]
   }
}
#......................................................................#	   
# Begin to decode severity
if [kv_field][severity]{
  if [kv_field][severity] == "9" or [kv_field][severity] == "10" or [kv_field][severity] == "11"
  or [kv_field][severity] == "12" or [kv_field][severity] == "13" or [kv_field][severity] == "14"
  or [kv_field][severity] == "15" or [kv_field][severity] == "CRITICAL" {
   mutate {
     add_field => {
       "[logx][privafy][severityLabel]" => "Very-High"
     }
   }	
  } else if [kv_field][severity] == "7" or [kv_field][severity] == "8" or [kv_field][severity] == "HIGH" {
   mutate {
     add_field => {
       "[logx][privafy][severityLabel]" => "High"
     }
   }	
  } else if [kv_field][severity] >= "4" and [kv_field][severity] <= "6" or [kv_field][severity] == "MEDIUM" {
   mutate {
     add_field => {
       "[logx][privafy][severityLabel]" => "Medium"
     }
   }	
  } else if [kv_field][severity] == "0" or [kv_field][severity] == "1" or [kv_field][severity] == "2"
  or [kv_field][severity] == "3" or [kv_field][severity] == "LOW" or [kv_field][severity] == "INFO" {
   mutate {
     add_field => {
       "[logx][privafy][severityLabel]" => "Low"
     }
   }	
  } else {
   mutate {
     add_field => {
       "[logx][privafy][severityLabel]" => "%{[kv_field][severity]}"
     }
   } 
  }
}
#......................................................................#
#Set null the fields with de X0X value (default string for null), and replace simple and double quotation
#also generate logx tree structure dynamically
          if [kv_field] {  
            ruby {
                code => '
                    event.get("[kv_field]").each do |k, v|
                          if (v == "X0X") 
                            event.set("[logx][privafy][#{k}]",nil)
                          elsif k.start_with?("-")
                            event.remove(k)
                          elsif k =~ /\W(.*)?/
                            event.remove(k)  
                          elsif !(v.kind_of?(Array))
                              new_v = v.to_s.gsub(/\"/, "")
                              new_v = new_v.gsub(/\'/, "")
                              event.set("[logx][privafy][#{k}]",new_v)
                          else
                              event.set("[logx][privafy][#{k}]",v)
                          end
                       end   
                    '
            }
          }
#......................................................................#
   #Finally, remove unnecessary fields
   mutate {
      remove_field => ["@version","path","tags","type","syslog_version","kv_field","prvf_message","[logx][syslog]",
      "not_defined","cef_or_leef_msg_all","cef_or_leef_msg","syslog_date_host","irrelevant","init_msg"]
   }
  }
# End CEF entrypoint

   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["@version","path","original_log_message","headers"]
   }
}
